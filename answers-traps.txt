1.函数参数的寄存器为 a0~a7. printf 的 13 存在寄存器 a2 中
2.在 40 行可以看到, 编译器进行了函数内联, 直接将 f(8)+1的值 12 计算出来了
3.由第 43 和 44 行可以看出, jalr 跳转的地址为 0x30+1536=0x630, 即函数 printf 的地址为 0x630
4.根据 jalr 指令的功能, 在刚跳转后 ra 的值为 pc+4=0x34+4=0x38
5.打印出了 He110 World。
首先，57616 转换为 16 进制为 e110，所以格式化描述符 %x 打印出了它的 16 进制值。
其次，如果在小端（little-endian）处理器中，数据0x00646c72 的高字节存储在内存的高位，那么从内存低位，也就是低字节开始读取，对应的 ASCII 字符为 rld。

如果在 大端（big-endian）处理器中，数据 0x00646c72 的高字节存储在内存的低位，那么从内存低位，也就是高字节开始读取其 ASCII 码为 dlr。
所以如果大端序和小端序输出相同的内容 i ，那么在其为大端序的时候，i 的值应该为 0x726c64，这样才能保证从内存低位读取时的输出为 rld 。
6.根据函数的传参规则, y= 后跟的值应该为寄存器 a2 的值。

